#pragma once

#ifdef __cplusplus
	#define CRY_FUN_SPEC inline constexpr
	#define CRY_IDTF(name) name
	#define STRUCTED_VAR

	#include <string>
	#include <cstddef>
	#define CRY_STRING_LENGTH_T size_t
#else
	#define CRY_FUN_SPEC inline
	#define CRY_IDTF(name) cry##name
	#define STRUCTED_VAR struct
	#define CRY_STRING_LENGTH_T int
#endif

#define CRY_STD_STR_TYPE const char*

#ifdef __cplusplus
namespace cry {
#endif

	#if __cplusplus >= 201703L
	struct StringPack_data : std::string_view {
		using std::string_view::string_view;
		StringPack_data(const char* s) : std::string_view(s) {}
	};
	#else
	struct CRY_IDTF(StringPack_data) {
                CRY_STD_STR_TYPE val;
                CRY_STRING_LENGTH_T len;

		#ifdef __cplusplus
		CRY_FUN_SPEC CRY_STRING_LENGTH_T size() {
			return len;
		}

		CRY_FUN_SPEC CRY_STD_STR_TYPE data() {
			return val;
		}
		#endif
	};
	#endif

	struct CRY_IDTF(Engine) {

		#ifdef __cplusplus
			struct Worker;
		#endif

		STRUCTED_VAR CRY_IDTF(StringPack_data) (*proc)(STRUCTED_VAR CRY_IDTF(StringPack_data) text, STRUCTED_VAR CRY_IDTF(StringPack_data) key);
        };


	struct
	#ifdef __cplusplus
		Engine::Worker
	#else
		cryEngineWorker
	#endif
	{
		STRUCTED_VAR CRY_IDTF(Engine) *engine;
		STRUCTED_VAR CRY_IDTF(StringPack_data) pack;

		#ifdef __cplusplus
		inline constexpr Worker(Engine *engine, STRUCTED_VAR CRY_IDTF(StringPack_data) pack) : engine(engine), pack(pack) {}
		inline constexpr CRY_IDTF(StringPack_data) proc(STRUCTED_VAR CRY_IDTF(StringPack_data) key);
		inline constexpr CRY_IDTF(StringPack_data) operator() (STRUCTED_VAR CRY_IDTF(StringPack_data) key) {
			return proc(key);
		}
		#endif
	};

	CRY_FUN_SPEC
	STRUCTED_VAR CRY_IDTF(StringPack_data)
	#ifdef __cplusplus
	Engine::Worker::proc
	#else
	cryEngineWorker_proc
	#endif
	(
	#ifndef __cplusplus
		struct cryEngineWorker *this, // Add " cryEngineWorker* " when it's C (when __cplusplus isn't defined) for compability between C and C++
	#endif
		STRUCTED_VAR CRY_IDTF(StringPack_data) key
	) {
		return this->engine->proc(this->pack, key);
	}

	struct CRY_IDTF(StringPack)
		#ifdef __cplusplus
		: public StringPack_data {
		#else
		{
		CRY_STD_STR_TYPE val;
		CRY_STRING_LENGTH_T len;
		#endif


		#ifdef __cplusplus

		#if __cplusplus >= 201703L
		StringPack(const char* s) : StringPack_data(s) {}
		#else
		inline StringPack(std::string val) : CRY_IDTF(StringPack_data) {val.c_str(), val.size()} {} // don't use it unless it's necessary, can't be declarated constexpr since accepting std::string as paramter !
		#endif

		inline constexpr StringPack(CRY_STD_STR_TYPE val, CRY_STRING_LENGTH_T len);

		inline constexpr Engine::Worker with(Engine *engine);
		inline constexpr Engine::Worker operator()(Engine *engine) {
			return with(engine);
		}
		#endif
	};

	CRY_FUN_SPEC
	#ifdef __cplusplus
		StringPack::StringPack(CRY_STD_STR_TYPE val, CRY_STRING_LENGTH_T len) : CRY_IDTF(StringPack_data) {val, len} {}
	#else
		struct cryStringPack
		cryStringPack_new(CRY_STD_STR_TYPE val, CRY_STRING_LENGTH_T len) {
			struct cryStringPack ret;
			ret.val = val;
			ret.len = len;
			return ret;
		}
	#endif


	CRY_FUN_SPEC
	#ifdef __cplusplus
		Engine::Worker
		StringPack::with(
	#else
		struct cryEngineWorker
		cryStringPack_with(STRUCTED_VAR cryStringPack *this,
	#endif
		STRUCTED_VAR CRY_IDTF(Engine) *engine
	) {
		#ifdef __cplusplus
	                return Engine::Worker(engine,
				StringPack_data(this->data(), this->size())
			);
        	#else
	                struct cryEngineWorker worker;
			worker.engine = engine;
			worker.pack = cryStringPack_data(this->val, this->len);
			return worker;
                #endif
	}

#ifdef __cplusplus
}
#endif

#ifdef __cplusplus
inline constexpr StringPack operator"" _cry(const char* str, size_t len) {
	return StringPack ( str, len );
}
#endif
